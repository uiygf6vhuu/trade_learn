# trading_bot_simple.py - H·ªÜ TH·ªêNG BOT TRADING ƒê∆†N GI·∫¢N HO√ÄN CH·ªàNH
import json
import logging
import hmac
import hashlib
import time
import threading
import urllib.request
import urllib.parse
import numpy as np
import requests
import os
import math
import traceback
import random
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

# ========== C·∫§U H√åNH LOGGING ==========
def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(module)s - %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('bot_simple_errors.log')
        ]
    )
    return logging.getLogger()

logger = setup_logging()

# ========== H√ÄM TELEGRAM ==========
def send_telegram(message, chat_id=None, reply_markup=None, bot_token=None, default_chat_id=None):
    if not bot_token:
        logger.warning("Telegram Bot Token ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p")
        return
    
    chat_id = chat_id or default_chat_id
    if not chat_id:
        logger.warning("Telegram Chat ID ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p")
        return
    
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": message,
        "parse_mode": "HTML"
    }
    
    if reply_markup:
        payload["reply_markup"] = json.dumps(reply_markup)
    
    try:
        response = requests.post(url, json=payload, timeout=15)
        if response.status_code != 200:
            logger.error(f"L·ªói Telegram ({response.status_code}): {response.text}")
    except Exception as e:
        logger.error(f"L·ªói k·∫øt n·ªëi Telegram: {str(e)}")

# ========== MENU TELEGRAM HO√ÄN CH·ªàNH ==========
def create_cancel_keyboard():
    return {
        "keyboard": [[{"text": "‚ùå H·ªßy b·ªè"}]],
        "resize_keyboard": True,
        "one_time_keyboard": True
    }

def create_main_menu():
    return {
        "keyboard": [
            [{"text": "üìä Danh s√°ch Bot"}, {"text": "üìä Th·ªëng k√™"}],
            [{"text": "‚ûï Th√™m Bot"}, {"text": "‚õî D·ª´ng Bot"}],
            [{"text": "üí∞ S·ªë d∆∞"}, {"text": "üìà V·ªã th·∫ø"}],
            [{"text": "‚öôÔ∏è C·∫•u h√¨nh"}, {"text": "üéØ Chi·∫øn l∆∞·ª£c"}]
        ],
        "resize_keyboard": True,
        "one_time_keyboard": False
    }

def create_leverage_keyboard():
    leverages = ["3", "5", "10", "15", "20", "25", "50", "75", "100"]
    
    keyboard = []
    row = []
    for lev in leverages:
        row.append({"text": f"{lev}x"})
        if len(row) == 3:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)
    keyboard.append([{"text": "‚ùå H·ªßy b·ªè"}])
    
    return {
        "keyboard": keyboard,
        "resize_keyboard": True,
        "one_time_keyboard": True
    }

def create_percent_keyboard():
    return {
        "keyboard": [
            [{"text": "1"}, {"text": "3"}, {"text": "5"}, {"text": "10"}],
            [{"text": "15"}, {"text": "20"}, {"text": "25"}, {"text": "50"}],
            [{"text": "‚ùå H·ªßy b·ªè"}]
        ],
        "resize_keyboard": True,
        "one_time_keyboard": True
    }

def create_tp_keyboard():
    return {
        "keyboard": [
            [{"text": "50"}, {"text": "100"}, {"text": "200"}],
            [{"text": "300"}, {"text": "500"}, {"text": "1000"}],
            [{"text": "‚ùå H·ªßy b·ªè"}]
        ],
        "resize_keyboard": True,
        "one_time_keyboard": True
    }

def create_sl_keyboard():
    return {
        "keyboard": [
            [{"text": "0"}, {"text": "50"}, {"text": "100"}],
            [{"text": "150"}, {"text": "200"}, {"text": "500"}],
            [{"text": "‚ùå H·ªßy b·ªè"}]
        ],
        "resize_keyboard": True,
        "one_time_keyboard": True
    }

def create_bot_count_keyboard():
    return {
        "keyboard": [
            [{"text": "1"}, {"text": "2"}, {"text": "3"}],
            [{"text": "5"}, {"text": "10"}],
            [{"text": "‚ùå H·ªßy b·ªè"}]
        ],
        "resize_keyboard": True,
        "one_time_keyboard": True
    }

# ========== PH√ÇN T√çCH VOLUME V√Ä N·∫æN ==========
class VolumeCandleAnalyzer:
    """PH√ÇN T√çCH XU H∆Ø·ªöNG D·ª∞A TR√äN VOLUME V√Ä N·∫æN"""
    
    def __init__(self):
        self.volume_threshold = 1.2  # Volume tƒÉng 20%
        self.small_body_ratio = 0.3  # Th√¢n n·∫øn nh·ªè < 30% range
        
    def analyze_volume_candle(self, symbol):
        """Ph√¢n t√≠ch volume v√† n·∫øn theo y√™u c·∫ßu"""
        try:
            # L·∫•y d·ªØ li·ªáu 3 khung th·ªùi gian
            intervals = ['1m', '5m', '15m']
            signals = []
            
            for interval in intervals:
                klines = self.get_klines(symbol, interval, 10)
                if not klines or len(klines) < 5:
                    continue
                    
                # Ph√¢n t√≠ch n·∫øn hi·ªán t·∫°i v√† volume
                current_candle = klines[-1]
                prev_candles = klines[-5:-1]
                
                open_price = float(current_candle[1])
                close_price = float(current_candle[4])
                high = float(current_candle[2])
                low = float(current_candle[3])
                current_volume = float(current_candle[5])
                
                # T√≠nh volume trung b√¨nh
                avg_volume = np.mean([float(c[5]) for c in prev_candles])
                
                # X√°c ƒë·ªãnh n·∫øn xanh/ƒë·ªè
                is_green = close_price > open_price
                is_red = close_price < open_price
                
                # X√°c ƒë·ªãnh th√¢n n·∫øn nh·ªè
                body_size = abs(close_price - open_price)
                total_range = high - low
                is_small_body = body_size < total_range * self.small_body_ratio if total_range > 0 else False
                
                # Volume tƒÉng/gi·∫£m
                volume_increase = current_volume > avg_volume * self.volume_threshold
                volume_decrease = current_volume < avg_volume * 0.8
                
                # √Åp d·ª•ng quy t·∫Øc
                if volume_increase and is_green:
                    signals.append("BUY")
                elif volume_increase and is_red:
                    signals.append("SELL")
                elif volume_decrease and is_small_body:
                    signals.append("BUY")  # Ch·ªâ mua khi volume gi·∫£m + n·∫øn th√¢n nh·ªè
                else:
                    signals.append("NEUTRAL")
            
            # Quy·∫øt ƒë·ªãnh d·ª±a tr√™n ƒëa s·ªë
            if signals.count("BUY") >= 2:
                return "BUY"
            elif signals.count("SELL") >= 2:
                return "SELL"
            else:
                return "NEUTRAL"
                
        except Exception as e:
            logger.error(f"L·ªói ph√¢n t√≠ch volume n·∫øn {symbol}: {str(e)}")
            return "NEUTRAL"
    
    def get_klines(self, symbol, interval, limit):
        """L·∫•y d·ªØ li·ªáu n·∫øn t·ª´ Binance"""
        try:
            url = "https://fapi.binance.com/fapi/v1/klines"
            params = {
                'symbol': symbol.upper(),
                'interval': interval,
                'limit': limit
            }
            return binance_api_request(url, params=params)
        except Exception as e:
            logger.error(f"L·ªói l·∫•y n·∫øn {symbol} {interval}: {str(e)}")
            return None

# ========== T√åM COIN TH√îNG MINH ==========
class SimpleCoinFinder:
    """T√åM COIN ƒê∆†N GI·∫¢N THEO Y√äU C·∫¶U"""
    
    def __init__(self, api_key, api_secret):
        self.api_key = api_key
        self.api_secret = api_secret
        self.analyzer = VolumeCandleAnalyzer()
        
    def find_coin_by_direction(self, target_direction, excluded_symbols=None):
        """T√¨m coin theo h∆∞·ªõng v·ªõi logic ƒë∆°n gi·∫£n"""
        try:
            if excluded_symbols is None:
                excluded_symbols = set()
            
            logger.info(f"üîç ƒêang t√¨m coin {target_direction}...")
            
            all_symbols = get_all_usdt_pairs(limit=600)
            if not all_symbols:
                return None
            
            # Tr·ªôn ng·∫´u nhi√™n
            random.shuffle(all_symbols)
            
            for symbol in all_symbols:
                try:
                    if symbol in excluded_symbols:
                        continue
                    
                    # Ph√¢n t√≠ch v·ªõi h·ªá th·ªëng volume/n·∫øn m·ªõi
                    signal = self.analyzer.analyze_volume_candle(symbol)
                    
                    if signal == target_direction:
                        logger.info(f"‚úÖ T√¨m th·∫•y {symbol} - {target_direction}")
                        return {
                            'symbol': symbol,
                            'direction': target_direction,
                            'qualified': True
                        }
                        
                except Exception as e:
                    continue
            
            logger.warning(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y coin {target_direction} ph√π h·ª£p")
            return None
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói t√¨m coin: {str(e)}")
            return None

# ========== API BINANCE ==========
def sign(query, api_secret):
    try:
        return hmac.new(api_secret.encode(), query.encode(), hashlib.sha256).hexdigest()
    except Exception as e:
        logger.error(f"L·ªói t·∫°o ch·ªØ k√Ω: {str(e)}")
        return ""

def binance_api_request(url, method='GET', params=None, headers=None):
    max_retries = 3
    for attempt in range(max_retries):
        try:
            if method.upper() == 'GET':
                if params:
                    query = urllib.parse.urlencode(params)
                    url = f"{url}?{query}"
                req = urllib.request.Request(url, headers=headers or {})
            else:
                data = urllib.parse.urlencode(params).encode() if params else None
                req = urllib.request.Request(url, data=data, headers=headers or {}, method=method)
            
            with urllib.request.urlopen(req, timeout=15) as response:
                if response.status == 200:
                    return json.loads(response.read().decode())
                else:
                    error_content = response.read().decode()
                    logger.error(f"L·ªói API ({response.status}): {error_content}")
                    if response.status == 401:
                        return None
                    if response.status == 429:
                        time.sleep(2 ** attempt)
                    elif response.status >= 500:
                        time.sleep(1)
                    continue
        except urllib.error.HTTPError as e:
            logger.error(f"L·ªói HTTP ({e.code}): {e.reason}")
            if e.code == 401:
                return None
            if e.code == 429:
                time.sleep(2 ** attempt)
            elif e.code >= 500:
                time.sleep(1)
            continue
        except Exception as e:
            logger.error(f"L·ªói k·∫øt n·ªëi API: {str(e)}")
            time.sleep(1)
    
    logger.error(f"Kh√¥ng th·ªÉ th·ª±c hi·ªán y√™u c·∫ßu API sau {max_retries} l·∫ßn th·ª≠")
    return None

def get_all_usdt_pairs(limit=600):
    try:
        url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
        data = binance_api_request(url)
        if not data:
            logger.warning("Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ Binance, tr·∫£ v·ªÅ danh s√°ch r·ªóng")
            return []
        
        usdt_pairs = []
        for symbol_info in data.get('symbols', []):
            symbol = symbol_info.get('symbol', '')
            if symbol.endswith('USDT') and symbol_info.get('status') == 'TRADING':
                usdt_pairs.append(symbol)
        
        logger.info(f"‚úÖ L·∫•y ƒë∆∞·ª£c {len(usdt_pairs)} coin USDT t·ª´ Binance")
        return usdt_pairs[:limit] if limit else usdt_pairs
        
    except Exception as e:
        logger.error(f"‚ùå L·ªói l·∫•y danh s√°ch coin t·ª´ Binance: {str(e)}")
        return []

def get_step_size(symbol, api_key, api_secret):
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = binance_api_request(url)
        if not data:
            return 0.001
        for s in data['symbols']:
            if s['symbol'] == symbol.upper():
                for f in s['filters']:
                    if f['filterType'] == 'LOT_SIZE':
                        return float(f['stepSize'])
    except Exception as e:
        logger.error(f"L·ªói l·∫•y step size: {str(e)}")
    return 0.001

def set_leverage(symbol, lev, api_key, api_secret):
    try:
        ts = int(time.time() * 1000)
        params = {
            "symbol": symbol.upper(),
            "leverage": lev,
            "timestamp": ts
        }
        query = urllib.parse.urlencode(params)
        sig = sign(query, api_secret)
        url = f"https://fapi.binance.com/fapi/v1/leverage?{query}&signature={sig}"
        headers = {'X-MBX-APIKEY': api_key}
        
        response = binance_api_request(url, method='POST', headers=headers)
        if response is None:
            return False
        if response and 'leverage' in response:
            return True
        return False
    except Exception as e:
        logger.error(f"L·ªói thi·∫øt l·∫≠p ƒë√≤n b·∫©y: {str(e)}")
        return False

def get_balance(api_key, api_secret):
    try:
        ts = int(time.time() * 1000)
        params = {"timestamp": ts}
        query = urllib.parse.urlencode(params)
        sig = sign(query, api_secret)
        url = f"https://fapi.binance.com/fapi/v2/account?{query}&signature={sig}"
        headers = {'X-MBX-APIKEY': api_key}
        
        data = binance_api_request(url, headers=headers)
        if not data:
            return None
        for asset in data['assets']:
            if asset['asset'] == 'USDT':
                return float(asset['availableBalance'])
        return 0
    except Exception as e:
        logger.error(f"L·ªói l·∫•y s·ªë d∆∞: {str(e)}")
        return None

def place_order(symbol, side, qty, api_key, api_secret):
    try:
        ts = int(time.time() * 1000)
        params = {
            "symbol": symbol.upper(),
            "side": side,
            "type": "MARKET",
            "quantity": qty,
            "timestamp": ts
        }
        query = urllib.parse.urlencode(params)
        sig = sign(query, api_secret)
        url = f"https://fapi.binance.com/fapi/v1/order?{query}&signature={sig}"
        headers = {'X-MBX-APIKEY': api_key}
        
        return binance_api_request(url, method='POST', headers=headers)
    except Exception as e:
        logger.error(f"L·ªói ƒë·∫∑t l·ªánh: {str(e)}")
    return None

def cancel_all_orders(symbol, api_key, api_secret):
    try:
        ts = int(time.time() * 1000)
        params = {"symbol": symbol.upper(), "timestamp": ts}
        query = urllib.parse.urlencode(params)
        sig = sign(query, api_secret)
        url = f"https://fapi.binance.com/fapi/v1/allOpenOrders?{query}&signature={sig}"
        headers = {'X-MBX-APIKEY': api_key}
        
        binance_api_request(url, method='DELETE', headers=headers)
        return True
    except Exception as e:
        logger.error(f"L·ªói h·ªßy l·ªánh: {str(e)}")
    return False

def get_current_price(symbol):
    try:
        url = f"https://fapi.binance.com/fapi/v1/ticker/price?symbol={symbol.upper()}"
        data = binance_api_request(url)
        if data and 'price' in data:
            return float(data['price'])
    except Exception as e:
        logger.error(f"L·ªói l·∫•y gi√°: {str(e)}")
    return 0

def get_positions(symbol=None, api_key=None, api_secret=None):
    try:
        ts = int(time.time() * 1000)
        params = {"timestamp": ts}
        if symbol:
            params["symbol"] = symbol.upper()
        query = urllib.parse.urlencode(params)
        sig = sign(query, api_secret)
        url = f"https://fapi.binance.com/fapi/v2/positionRisk?{query}&signature={sig}"
        headers = {'X-MBX-APIKEY': api_key}
        
        positions = binance_api_request(url, headers=headers)
        if not positions:
            return []
        if symbol:
            for pos in positions:
                if pos['symbol'] == symbol.upper():
                    return [pos]
        return positions
    except Exception as e:
        logger.error(f"L·ªói l·∫•y v·ªã th·∫ø: {str(e)}")
    return []

def get_24h_change(symbol):
    try:
        url = f"https://fapi.binance.com/fapi/v1/ticker/24hr?symbol={symbol.upper()}"
        data = binance_api_request(url)
        if data and 'priceChangePercent' in data:
            change = data['priceChangePercent']
            if change is None:
                return 0.0
            return float(change) if change is not None else 0.0
        return 0.0
    except Exception as e:
        logger.error(f"L·ªói l·∫•y bi·∫øn ƒë·ªông 24h cho {symbol}: {str(e)}")
    return 0.0

# ========== BOT TRADING ƒê∆†N GI·∫¢N ==========
class SimpleTrendBot:
    """BOT ƒê∆†N GI·∫¢N THEO Y√äU C·∫¶U"""
    
    def __init__(self, lev, percent, tp, sl, api_key, api_secret, telegram_bot_token=None, telegram_chat_id=None, bot_id=None):
        self.lev = lev
        self.percent = percent
        self.tp = tp
        self.sl = sl
        self.api_key = api_key
        self.api_secret = api_secret
        self.telegram_bot_token = telegram_bot_token
        self.telegram_chat_id = telegram_chat_id
        self.bot_id = bot_id or f"SimpleBot_{int(time.time())}_{random.randint(1000, 9999)}"
        
        self.symbol = None
        self.status = "searching"  # searching, open, closed
        self.side = ""
        self.entry_price = 0
        self.position_size = 0
        
        self.coin_finder = SimpleCoinFinder(api_key, api_secret)
        self.analyzer = VolumeCandleAnalyzer()
        
        self._stop = False
        self.thread = threading.Thread(target=self._run, daemon=True)
        self.thread.start()
        
        self.log(f"üü¢ Bot kh·ªüi ƒë·ªông - ƒêB: {lev}x, V·ªën: {percent}%, TP: {tp}%, SL: {sl}%")
    
    def log(self, message):
        """Ghi log v√† g·ª≠i Telegram"""
        logger.info(f"[Bot {self.bot_id}] {message}")
        if self.telegram_bot_token and self.telegram_chat_id:
            symbol_info = f"<b>{self.symbol}</b>" if self.symbol else "<i>ƒêang t√¨m coin...</i>"
            send_telegram(f"{symbol_info} (Bot {self.bot_id}): {message}", 
                         bot_token=self.telegram_bot_token, 
                         default_chat_id=self.telegram_chat_id)

    def _run(self):
        """V√≤ng l·∫∑p ch√≠nh c·ªßa bot - TH·ª∞C HI·ªÜN 5 B∆Ø·ªöC"""
        while not self._stop:
            try:
                # B∆Ø·ªöC 1 & 2 & 3 & 4: T√¨m v√† m·ªü v·ªã th·∫ø n·∫øu ƒëang t√¨m ki·∫øm
                if self.status == "searching":
                    self._find_and_open_position()
                
                # B∆Ø·ªöC 4: Ki·ªÉm tra TP/SL n·∫øu ƒëang c√≥ v·ªã th·∫ø
                elif self.status == "open":
                    self._check_tp_sl()
                
                time.sleep(5)  # Ki·ªÉm tra m·ªói 5 gi√¢y
                
            except Exception as e:
                self.log(f"‚ùå L·ªói h·ªá th·ªëng: {str(e)}")
                time.sleep(10)
    
    def _find_and_open_position(self):
        """B∆Ø·ªöC 1, 2, 3, 4: T√¨m v√† m·ªü v·ªã th·∫ø"""
        try:
            # B∆Ø·ªöC 1: X√°c ƒë·ªãnh h∆∞·ªõng giao d·ªãch d·ª±a tr√™n v·ªã th·∫ø hi·ªán c√≥
            target_direction = self._get_market_direction()
            if not target_direction:
                return
            
            self.log(f"üéØ H∆∞·ªõng giao d·ªãch: {target_direction}")
            
            # B∆Ø·ªöC 2 & 3: T√¨m coin ph√π h·ª£p
            coin_data = self.coin_finder.find_coin_by_direction(target_direction)
            if not coin_data:
                return
            
            symbol = coin_data['symbol']
            direction = coin_data['direction']
            
            # B∆Ø·ªöC 4: Ki·ªÉm tra v√† v√†o l·ªánh
            if self._open_position(symbol, direction):
                self.status = "open"
                self.log(f"‚úÖ ƒê√£ v√†o l·ªánh {direction} {symbol}")
                
        except Exception as e:
            self.log(f"‚ùå L·ªói t√¨m v√† m·ªü v·ªã th·∫ø: {str(e)}")
    
    def _get_market_direction(self):
        """B∆Ø·ªöC 1: Ki·ªÉm tra v√† x√°c ƒë·ªãnh h∆∞·ªõng giao d·ªãch"""
        try:
            positions = get_positions(api_key=self.api_key, api_secret=self.api_secret)
            
            long_count = 0
            short_count = 0
            
            for pos in positions:
                position_amt = float(pos.get('positionAmt', 0))
                if position_amt > 0:
                    long_count += 1
                elif position_amt < 0:
                    short_count += 1
            
            self.log(f"üìä V·ªã th·∫ø hi·ªán t·∫°i: {long_count} LONG, {short_count} SHORT")
            
            # Quy·∫øt ƒë·ªãnh h∆∞·ªõng ng∆∞·ª£c l·∫°i v·ªõi b√™n nhi·ªÅu h∆°n
            if long_count > short_count:
                return "SELL"
            elif short_count > long_count:
                return "BUY"
            else:
                # N·∫øu c√¢n b·∫±ng, ch·ªçn ng·∫´u nhi√™n
                return random.choice(["BUY", "SELL"])
                
        except Exception as e:
            self.log(f"‚ùå L·ªói x√°c ƒë·ªãnh h∆∞·ªõng: {str(e)}")
            return random.choice(["BUY", "SELL"])
    
    def _open_position(self, symbol, direction):
        """B∆Ø·ªöC 4: M·ªü v·ªã th·∫ø"""
        try:
            # Ki·ªÉm tra s·ªë d∆∞
            balance = get_balance(self.api_key, self.api_secret)
            if balance is None or balance <= 0:
                self.log("‚ùå Kh√¥ng ƒë·ªß s·ªë d∆∞")
                return False
            
            # Ki·ªÉm tra ƒë√£ c√≥ v·ªã th·∫ø v·ªõi coin n√†y ch∆∞a
            existing_positions = get_positions(symbol, self.api_key, self.api_secret)
            for pos in existing_positions:
                position_amt = float(pos.get('positionAmt', 0))
                if position_amt != 0:
                    self.log(f"‚ö†Ô∏è ƒê√£ c√≥ v·ªã th·∫ø v·ªõi {symbol}, b·ªè qua")
                    return False
            
            # ƒê·∫∑t ƒë√≤n b·∫©y
            if not set_leverage(symbol, self.lev, self.api_key, self.api_secret):
                self.log(f"‚ùå Kh√¥ng th·ªÉ ƒë·∫∑t ƒë√≤n b·∫©y {self.lev}x")
                return False
            
            # T√≠nh s·ªë l∆∞·ª£ng theo c√¥ng th·ª©c: s·ªë d∆∞ kh·∫£ d·ª•ng * % s·ªë d∆∞ * ƒë√≤n b·∫©y / 100
            current_price = get_current_price(symbol)
            if current_price <= 0:
                self.log("‚ùå L·ªói l·∫•y gi√°")
                return False
            
            # T√≠nh to√°n s·ªë l∆∞·ª£ng
            usd_amount = balance * (self.percent / 100)
            position_value = usd_amount * self.lev
            qty = position_value / current_price
            
            # L√†m tr√≤n theo step size
            step_size = get_step_size(symbol, self.api_key, self.api_secret)
            if step_size > 0:
                qty = math.floor(qty / step_size) * step_size
                qty = round(qty, 8)
            
            if qty < step_size:
                self.log(f"‚ùå S·ªë l∆∞·ª£ng qu√° nh·ªè: {qty}")
                return False
            
            self.log(f"üìä ƒêang ƒë·∫∑t l·ªánh {direction} - SL: {step_size}, Qty: {qty}, Gi√°: {current_price}")
            
            # ƒê·∫∑t l·ªánh
            result = place_order(symbol, direction, qty, self.api_key, self.api_secret)
            if result and 'orderId' in result:
                executed_qty = float(result.get('executedQty', 0))
                avg_price = float(result.get('avgPrice', current_price))
                
                if executed_qty > 0:
                    self.symbol = symbol
                    self.side = direction
                    self.entry_price = avg_price
                    self.position_size = executed_qty
                    
                    message = (
                        f"‚úÖ <b>ƒê√É M·ªû V·ªä TH·∫æ</b>\n"
                        f"üîó Coin: {symbol}\n"
                        f"üìå H∆∞·ªõng: {direction}\n"
                        f"üè∑Ô∏è Gi√° v√†o: {self.entry_price:.4f}\n"
                        f"üìä Kh·ªëi l∆∞·ª£ng: {executed_qty:.4f}\n"
                        f"üíµ Gi√° tr·ªã: {executed_qty * self.entry_price:.2f} USDT\n"
                        f"üí∞ ƒê√≤n b·∫©y: {self.lev}x\n"
                        f"üéØ TP: {self.tp}% | üõ°Ô∏è SL: {self.sl}%"
                    )
                    self.log(message)
                    return True
                else:
                    self.log(f"‚ùå L·ªánh kh√¥ng kh·ªõp - S·ªë l∆∞·ª£ng: {qty}")
                    return False
            else:
                error_msg = result.get('msg', 'Unknown error') if result else 'No response'
                self.log(f"‚ùå L·ªói ƒë·∫∑t l·ªánh {direction}: {error_msg}")
                return False
                    
        except Exception as e:
            self.log(f"‚ùå L·ªói m·ªü l·ªánh: {str(e)}")
            return False
    
    def _check_tp_sl(self):
        """B∆Ø·ªöC 4: Ki·ªÉm tra TP/SL"""
        if not self.symbol or self.entry_price <= 0:
            return
        
        current_price = get_current_price(self.symbol)
        if current_price <= 0:
            return
        
        # T√≠nh PnL %
        if self.side == "BUY":
            pnl_percent = ((current_price - self.entry_price) / self.entry_price) * 100
        else:
            pnl_percent = ((self.entry_price - current_price) / self.entry_price) * 100
        
        # Ki·ªÉm tra TP/SL
        if self.tp and pnl_percent >= self.tp:
            self._close_position(f"‚úÖ ƒê·∫°t TP {self.tp}% (ROI: {pnl_percent:.2f}%)")
        elif self.sl and pnl_percent <= -self.sl:
            self._close_position(f"‚ùå ƒê·∫°t SL {self.sl}% (ROI: {pnl_percent:.2f}%)")
    
    def _close_position(self, reason=""):
        """B∆Ø·ªöC 4: ƒê√≥ng v·ªã th·∫ø"""
        try:
            if not self.symbol:
                return False

            close_side = "SELL" if self.side == "BUY" else "BUY"
            
            # H·ªßy t·∫•t c·∫£ l·ªánh ch·ªù
            cancel_all_orders(self.symbol, self.api_key, self.api_secret)
            time.sleep(0.5)
            
            # ƒê√≥ng l·ªánh
            result = place_order(self.symbol, close_side, self.position_size, self.api_key, self.api_secret)
            if result and 'orderId' in result:
                current_price = get_current_price(self.symbol)
                
                message = (
                    f"‚õî <b>ƒê√É ƒê√ìNG V·ªä TH·∫æ</b>\n"
                    f"üîó Coin: {self.symbol}\n"
                    f"üìå L√Ω do: {reason}\n"
                    f"üè∑Ô∏è Gi√° ra: {current_price:.4f}\n"
                    f"üìä Kh·ªëi l∆∞·ª£ng: {self.position_size:.4f}"
                )
                self.log(message)
                
                # B∆Ø·ªöC 4: Reset tr·∫°ng th√°i v·ªÅ ch∆∞a v√†o l·ªánh
                self._reset_position()
                return True
            else:
                error_msg = result.get('msg', 'Unknown error') if result else 'No response'
                self.log(f"‚ùå L·ªói ƒë√≥ng l·ªánh: {error_msg}")
                return False
                
        except Exception as e:
            self.log(f"‚ùå L·ªói ƒë√≥ng l·ªánh: {str(e)}")
            return False
    
    def _reset_position(self):
        """Reset tr·∫°ng th√°i bot v·ªÅ ban ƒë·∫ßu"""
        self.symbol = None
        self.status = "searching"
        self.side = ""
        self.entry_price = 0
        self.position_size = 0
    
    def stop(self):
        """D·ª´ng bot"""
        self._stop = True
        if self.status == "open":
            self._close_position("D·ª´ng bot")
        self.log("üî¥ Bot ƒë√£ d·ª´ng")
    
    def get_info(self):
        """L·∫•y th√¥ng tin bot"""
        return {
            'bot_id': self.bot_id,
            'symbol': self.symbol,
            'status': self.status,
            'side': self.side,
            'lev': self.lev,
            'percent': self.percent,
            'tp': self.tp,
            'sl': self.sl,
            'entry_price': self.entry_price,
            'position_size': self.position_size
        }

# ========== QU·∫¢N L√ù BOT ƒê∆†N GI·∫¢N ==========
class BotManager:
    """QU·∫¢N L√ù BOT ƒê∆†N GI·∫¢N"""
    
    def __init__(self, api_key=None, api_secret=None, telegram_bot_token=None, telegram_chat_id=None):
        self.api_key = api_key
        self.api_secret = api_secret
        self.telegram_bot_token = telegram_bot_token
        self.telegram_chat_id = telegram_chat_id
        
        self.bots = []
        self.running = True
        self.user_states = {}
        
        if api_key and api_secret:
            self._verify_api_connection()
            self.log("üü¢ H·ªÜ TH·ªêNG BOT ƒê∆†N GI·∫¢N ƒê√É KH·ªûI ƒê·ªòNG")
            
            if self.telegram_bot_token and self.telegram_chat_id:
                self.telegram_thread = threading.Thread(target=self._telegram_listener, daemon=True)
                self.telegram_thread.start()
                
                self.send_main_menu(self.telegram_chat_id)
        else:
            self.log("‚ö° BotManager kh·ªüi ƒë·ªông ·ªü ch·∫ø ƒë·ªô kh√¥ng config")

    def _verify_api_connection(self):
        balance = get_balance(self.api_key, self.api_secret)
        if balance is None:
            self.log("‚ùå L·ªñI: Kh√¥ng th·ªÉ k·∫øt n·ªëi Binance API.")
        else:
            self.log(f"‚úÖ K·∫øt n·ªëi Binance th√†nh c√¥ng! S·ªë d∆∞: {balance:.2f} USDT")

    def log(self, message):
        logger.info(f"[SYSTEM] {message}")
        if self.telegram_bot_token and self.telegram_chat_id:
            send_telegram(f"<b>SYSTEM</b>: {message}", 
                         bot_token=self.telegram_bot_token, 
                         default_chat_id=self.telegram_chat_id)

    def send_main_menu(self, chat_id):
        welcome = "ü§ñ <b>BOT GIAO D·ªäCH FUTURES ƒê∆†N GI·∫¢N</b>\n\nüéØ <b>H·ªÜ TH·ªêNG D·ª∞A TR√äN VOLUME V√Ä N·∫æN</b>"
        send_telegram(welcome, chat_id, create_main_menu(),
                     bot_token=self.telegram_bot_token, 
                     default_chat_id=self.telegram_chat_id)

    def add_bots(self, bot_count, lev, percent, tp, sl):
        """Th√™m nhi·ªÅu bot - M·ªói bot ch·∫°y thread ri√™ng"""
        created_count = 0
        
        for i in range(bot_count):
            try:
                bot_id = f"Bot_{i+1}_{int(time.time())}"
                bot = SimpleTrendBot(lev, percent, tp, sl, self.api_key, self.api_secret,
                                   self.telegram_bot_token, self.telegram_chat_id, bot_id)
                self.bots.append(bot)
                created_count += 1
                
            except Exception as e:
                self.log(f"‚ùå L·ªói t·∫°o bot {i}: {str(e)}")
                continue
        
        if created_count > 0:
            success_msg = (
                f"‚úÖ <b>ƒê√É T·∫†O {created_count} BOT ƒê·ªòC L·∫¨P</b>\n\n"
                f"ü§ñ S·ªë l∆∞·ª£ng: {created_count} bot\n"
                f"üí∞ ƒê√≤n b·∫©y: {lev}x\n"
                f"üìä % S·ªë d∆∞: {percent}%\n"
                f"üéØ TP: {tp}%\n"
                f"üõ°Ô∏è SL: {sl}%\n\n"
                f"üéØ <b>M·ªói bot l√† 1 thread ƒë·ªôc l·∫≠p</b>\n"
                f"üîÑ <b>T·ª± ƒë·ªông t√¨m coin & trade</b>\n"
                f"üìä <b>T·ª± reset sau m·ªói l·ªánh</b>"
            )
            
            self.log(success_msg)
            return True
        else:
            self.log("‚ùå Kh√¥ng th·ªÉ t·∫°o bot n√†o")
            return False

    def get_statistics(self):
        """B∆Ø·ªöC 5: Th·ªëng k√™ h·ªá th·ªëng"""
        try:
            # S·ªë d∆∞
            balance = get_balance(self.api_key, self.api_secret)
            
            # Th·ªëng k√™ bot
            searching_bots = sum(1 for bot in self.bots if bot.status == "searching")
            open_bots = sum(1 for bot in self.bots if bot.status == "open")
            
            # V·ªã th·∫ø tr√™n Binance (bao g·ªìm c·∫£ ngo√†i h·ªá th·ªëng)
            positions = get_positions(api_key=self.api_key, api_secret=self.api_secret)
            binance_positions = []
            
            for pos in positions:
                position_amt = float(pos.get('positionAmt', 0))
                if position_amt != 0:
                    symbol = pos.get('symbol', 'UNKNOWN')
                    entry = float(pos.get('entryPrice', 0))
                    side = "LONG" if position_amt > 0 else "SHORT"
                    pnl = float(pos.get('unRealizedProfit', 0))
                    leverage = float(pos.get('leverage', 1))
                    
                    binance_positions.append({
                        'symbol': symbol,
                        'side': side,
                        'entry': entry,
                        'leverage': leverage,
                        'pnl': pnl
                    })
            
            stats = (
                f"üìä **TH·ªêNG K√ä TO√ÄN H·ªÜ TH·ªêNG**\n\n"
                f"üí∞ S·ªë d∆∞: {balance:.2f} USDT\n"
                f"ü§ñ T·ªïng bot: {len(self.bots)}\n"
                f"üîç ƒêang t√¨m coin: {searching_bots}\n"
                f"üìà ƒêang trade: {open_bots}\n"
            )
            
            # Th√¥ng tin bot chi ti·∫øt
            if self.bots:
                stats += f"\nü§ñ **CHI TI·∫æT BOT**:\n"
                for bot in self.bots:
                    info = bot.get_info()
                    symbol_info = info['symbol'] if info['symbol'] else "ƒêang t√¨m..."
                    status_map = {"searching": "üîç T√¨m coin", "open": "üìà ƒêang trade"}
                    status = status_map.get(info['status'], info['status'])
                    
                    stats += (
                        f"üîπ {info['bot_id']}\n"
                        f"   üìä {symbol_info} | {status}\n"
                        f"   üí∞ ƒêB: {info['lev']}x | V·ªën: {info['percent']}%\n"
                        f"   üéØ TP: {info['tp']}% | üõ°Ô∏è SL: {info['sl']}%\n\n"
                    )
            
            # V·ªã th·∫ø Binance
            if binance_positions:
                stats += f"\nüí∞ **V·ªä TH·∫æ BINANCE**:\n"
                for pos in binance_positions:
                    stats += (
                        f"üîπ {pos['symbol']} | {pos['side']}\n"
                        f"   üè∑Ô∏è Gi√° v√†o: {pos['entry']:.4f}\n"
                        f"   üí∞ ƒêB: {pos['leverage']}x | PnL: {pos['pnl']:.2f} USDT\n\n"
                    )
            
            return stats
                    
        except Exception as e:
            return f"‚ùå L·ªói th·ªëng k√™: {str(e)}"

    def stop_all(self):
        """D·ª´ng t·∫•t c·∫£ bot"""
        self.log("‚õî ƒêang d·ª´ng t·∫•t c·∫£ bot...")
        for bot in self.bots:
            bot.stop()
        self.bots.clear()
        self.running = False
        self.log("üî¥ ƒê√£ d·ª´ng t·∫•t c·∫£ bot")

    def stop_bot(self, bot_id):
        """D·ª´ng bot c·ª• th·ªÉ"""
        for bot in self.bots:
            if bot.bot_id == bot_id:
                bot.stop()
                self.bots.remove(bot)
                self.log(f"‚õî ƒê√£ d·ª´ng bot {bot_id}")
                return True
        return False

    def _telegram_listener(self):
        """L·∫Øng nghe tin nh·∫Øn Telegram"""
        last_update_id = 0
        
        while self.running and self.telegram_bot_token:
            try:
                url = f"https://api.telegram.org/bot{self.telegram_bot_token}/getUpdates?offset={last_update_id+1}&timeout=30"
                response = requests.get(url, timeout=35)
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('ok'):
                        for update in data['result']:
                            update_id = update['update_id']
                            message = update.get('message', {})
                            chat_id = str(message.get('chat', {}).get('id'))
                            text = message.get('text', '').strip()
                            
                            if chat_id != self.telegram_chat_id:
                                continue
                            
                            if update_id > last_update_id:
                                last_update_id = update_id
                            
                            self._handle_telegram_message(chat_id, text)
                elif response.status_code == 409:
                    logger.error("L·ªói xung ƒë·ªôt Telegram")
                    time.sleep(60)
                else:
                    time.sleep(10)
                
            except Exception as e:
                logger.error(f"L·ªói Telegram listener: {str(e)}")
                time.sleep(10)

    def _handle_telegram_message(self, chat_id, text):
        """X·ª≠ l√Ω tin nh·∫Øn Telegram"""
        user_state = self.user_states.get(chat_id, {})
        current_step = user_state.get('step')
        
        # X·ª≠ l√Ω c√°c b∆∞·ªõc th√™m bot
        if current_step == 'waiting_bot_count':
            if text == '‚ùå H·ªßy b·ªè':
                self.user_states[chat_id] = {}
                send_telegram("‚ùå ƒê√£ h·ªßy th√™m bot", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
            else:
                try:
                    bot_count = int(text)
                    if bot_count <= 0 or bot_count > 10:
                        send_telegram("‚ö†Ô∏è S·ªë l∆∞·ª£ng bot ph·∫£i t·ª´ 1 ƒë·∫øn 10. Vui l√≤ng ch·ªçn l·∫°i:",
                                    chat_id, create_bot_count_keyboard(),
                                    self.telegram_bot_token, self.telegram_chat_id)
                        return

                    user_state['bot_count'] = bot_count
                    user_state['step'] = 'waiting_leverage'
                    
                    send_telegram(
                        f"ü§ñ S·ªë l∆∞·ª£ng bot: {bot_count}\n\n"
                        f"Ch·ªçn ƒë√≤n b·∫©y:",
                        chat_id,
                        create_leverage_keyboard(),
                        self.telegram_bot_token, self.telegram_chat_id
                    )
                except ValueError:
                    send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá cho s·ªë l∆∞·ª£ng bot:",
                                chat_id, create_bot_count_keyboard(),
                                self.telegram_bot_token, self.telegram_chat_id)

        elif current_step == 'waiting_leverage':
            if text == '‚ùå H·ªßy b·ªè':
                self.user_states[chat_id] = {}
                send_telegram("‚ùå ƒê√£ h·ªßy th√™m bot", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
            else:
                if text.endswith('x'):
                    lev_text = text[:-1]
                else:
                    lev_text = text

                try:
                    leverage = int(lev_text)
                    if leverage <= 0 or leverage > 100:
                        send_telegram("‚ö†Ô∏è ƒê√≤n b·∫©y ph·∫£i t·ª´ 1 ƒë·∫øn 100. Vui l√≤ng ch·ªçn l·∫°i:",
                                    chat_id, create_leverage_keyboard(),
                                    self.telegram_bot_token, self.telegram_chat_id)
                        return

                    user_state['leverage'] = leverage
                    user_state['step'] = 'waiting_percent'
                    
                    balance = get_balance(self.api_key, self.api_secret)
                    balance_info = f"\nüí∞ S·ªë d∆∞ hi·ªán c√≥: {balance:.2f} USDT" if balance else ""
                    
                    send_telegram(
                        f"üí∞ ƒê√≤n b·∫©y: {leverage}x{balance_info}\n\n"
                        f"Ch·ªçn % s·ªë d∆∞ cho m·ªói l·ªánh:",
                        chat_id,
                        create_percent_keyboard(),
                        self.telegram_bot_token, self.telegram_chat_id
                    )
                except ValueError:
                    send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá cho ƒë√≤n b·∫©y:",
                                chat_id, create_leverage_keyboard(),
                                self.telegram_bot_token, self.telegram_chat_id)

        elif current_step == 'waiting_percent':
            if text == '‚ùå H·ªßy b·ªè':
                self.user_states[chat_id] = {}
                send_telegram("‚ùå ƒê√£ h·ªßy th√™m bot", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
            else:
                try:
                    percent = float(text)
                    if percent <= 0 or percent > 100:
                        send_telegram("‚ö†Ô∏è % s·ªë d∆∞ ph·∫£i t·ª´ 0.1 ƒë·∫øn 100. Vui l√≤ng ch·ªçn l·∫°i:",
                                    chat_id, create_percent_keyboard(),
                                    self.telegram_bot_token, self.telegram_chat_id)
                        return

                    user_state['percent'] = percent
                    user_state['step'] = 'waiting_tp'
                    
                    balance = get_balance(self.api_key, self.api_secret)
                    actual_amount = balance * (percent / 100) if balance else 0
                    
                    send_telegram(
                        f"üìä % S·ªë d∆∞: {percent}%\n"
                        f"üíµ S·ªë ti·ªÅn m·ªói l·ªánh: ~{actual_amount:.2f} USDT\n\n"
                        f"Ch·ªçn Take Profit (%):",
                        chat_id,
                        create_tp_keyboard(),
                        self.telegram_bot_token, self.telegram_chat_id
                    )
                except ValueError:
                    send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá cho % s·ªë d∆∞:",
                                chat_id, create_percent_keyboard(),
                                self.telegram_bot_token, self.telegram_chat_id)

        elif current_step == 'waiting_tp':
            if text == '‚ùå H·ªßy b·ªè':
                self.user_states[chat_id] = {}
                send_telegram("‚ùå ƒê√£ h·ªßy th√™m bot", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
            else:
                try:
                    tp = float(text)
                    if tp <= 0:
                        send_telegram("‚ö†Ô∏è Take Profit ph·∫£i l·ªõn h∆°n 0. Vui l√≤ng ch·ªçn l·∫°i:",
                                    chat_id, create_tp_keyboard(),
                                    self.telegram_bot_token, self.telegram_chat_id)
                        return

                    user_state['tp'] = tp
                    user_state['step'] = 'waiting_sl'
                    
                    send_telegram(
                        f"üéØ Take Profit: {tp}%\n\n"
                        f"Ch·ªçn Stop Loss (%):",
                        chat_id,
                        create_sl_keyboard(),
                        self.telegram_bot_token, self.telegram_chat_id
                    )
                except ValueError:
                    send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá cho Take Profit:",
                                chat_id, create_tp_keyboard(),
                                self.telegram_bot_token, self.telegram_chat_id)

        elif current_step == 'waiting_sl':
            if text == '‚ùå H·ªßy b·ªè':
                self.user_states[chat_id] = {}
                send_telegram("‚ùå ƒê√£ h·ªßy th√™m bot", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
            else:
                try:
                    sl = float(text)
                    if sl < 0:
                        send_telegram("‚ö†Ô∏è Stop Loss ph·∫£i l·ªõn h∆°n ho·∫∑c b·∫±ng 0. Vui l√≤ng ch·ªçn l·∫°i:",
                                    chat_id, create_sl_keyboard(),
                                    self.telegram_bot_token, self.telegram_chat_id)
                        return

                    user_state['sl'] = sl
                    
                    # L·∫•y th√¥ng tin t·ª´ user_state
                    bot_count = user_state.get('bot_count', 1)
                    leverage = user_state.get('leverage')
                    percent = user_state.get('percent')
                    tp = user_state.get('tp')
                    sl = user_state.get('sl')
                    
                    success = self.add_bots(bot_count, leverage, percent, tp, sl)

                    if success:
                        success_msg = (
                            f"‚úÖ <b>ƒê√É T·∫†O {bot_count} BOT TH√ÄNH C√îNG</b>\n\n"
                            f"ü§ñ S·ªë l∆∞·ª£ng: {bot_count} bot ƒë·ªôc l·∫≠p\n"
                            f"üí∞ ƒê√≤n b·∫©y: {leverage}x\n"
                            f"üìä % S·ªë d∆∞: {percent}%\n"
                            f"üéØ TP: {tp}%\n"
                            f"üõ°Ô∏è SL: {sl}%\n\n"
                            f"üéØ <b>M·ªói bot l√† 1 thread ƒë·ªôc l·∫≠p</b>\n"
                            f"üîÑ <b>T·ª± ƒë·ªông t√¨m coin & trade</b>\n"
                            f"üìä <b>T·ª± reset sau m·ªói l·ªánh</b>"
                        )

                        send_telegram(success_msg, chat_id, create_main_menu(),
                                    self.telegram_bot_token, self.telegram_chat_id)
                    else:
                        send_telegram("‚ùå C√≥ l·ªói khi t·∫°o bot. Vui l√≤ng th·ª≠ l·∫°i.",
                                    chat_id, create_main_menu(),
                                    self.telegram_bot_token, self.telegram_chat_id)
                    
                    self.user_states[chat_id] = {}
                    
                except ValueError:
                    send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá cho Stop Loss:",
                                chat_id, create_sl_keyboard(),
                                self.telegram_bot_token, self.telegram_chat_id)

        # X·ª≠ l√Ω menu ch√≠nh
        elif text == "‚ûï Th√™m Bot":
            self.user_states[chat_id] = {'step': 'waiting_bot_count'}
            balance = get_balance(self.api_key, self.api_secret)
            if balance is None:
                send_telegram("‚ùå <b>L·ªñI K·∫æT N·ªêI BINANCE</b>\nVui l√≤ng ki·ªÉm tra API Key!", chat_id,
                            bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
                return
            
            send_telegram(
                f"üéØ <b>CH·ªåN S·ªê L∆Ø·ª¢NG BOT ƒê·ªòC L·∫¨P</b>\n\n"
                f"üí∞ S·ªë d∆∞ hi·ªán c√≥: <b>{balance:.2f} USDT</b>\n\n"
                f"Ch·ªçn s·ªë l∆∞·ª£ng bot ƒë·ªôc l·∫≠p b·∫°n mu·ªën t·∫°o:\n"
                f"<i>M·ªói bot s·∫Ω t·ª± t√¨m coin & trade ƒë·ªôc l·∫≠p</i>",
                chat_id,
                create_bot_count_keyboard(),
                self.telegram_bot_token, self.telegram_chat_id
            )
        
        elif text == "üìä Danh s√°ch Bot":
            if not self.bots:
                send_telegram("ü§ñ Kh√¥ng c√≥ bot n√†o ƒëang ch·∫°y", chat_id,
                            bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
            else:
                message = "ü§ñ <b>DANH S√ÅCH BOT ƒê·ªòC L·∫¨P ƒêANG CH·∫†Y</b>\n\n"
                
                for bot in self.bots:
                    info = bot.get_info()
                    symbol_info = info['symbol'] if info['symbol'] else "ƒêang t√¨m..."
                    status_map = {"searching": "üîç ƒêang t√¨m coin", "open": "üìà ƒêang trade"}
                    status = status_map.get(info['status'], info['status'])
                    
                    message += f"üîπ {info['bot_id']}\n"
                    message += f"   üìä {symbol_info} | {status}\n"
                    message += f"   üí∞ ƒêB: {info['lev']}x | V·ªën: {info['percent']}%\n\n"
                
                message += f"üìà T·ªïng s·ªë: {len(self.bots)} bot"
                
                send_telegram(message, chat_id,
                            bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        
        elif text == "üìä Th·ªëng k√™":
            summary = self.get_statistics()
            send_telegram(summary, chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        
        elif text == "‚õî D·ª´ng Bot":
            if not self.bots:
                send_telegram("ü§ñ Kh√¥ng c√≥ bot n√†o ƒëang ch·∫°y", chat_id,
                            bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
            else:
                self.stop_all()
                send_telegram("‚õî ƒê√£ d·ª´ng t·∫•t c·∫£ bot", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
        
        elif text == "üí∞ S·ªë d∆∞":
            try:
                balance = get_balance(self.api_key, self.api_secret)
                if balance is None:
                    send_telegram("‚ùå <b>L·ªñI K·∫æT N·ªêI BINANCE</b>\nVui l√≤ng ki·ªÉm tra API Key!", chat_id,
                                bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
                else:
                    send_telegram(f"üí∞ <b>S·ªê D∆Ø KH·∫¢ D·ª§NG</b>: {balance:.2f} USDT", chat_id,
                                bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
            except Exception as e:
                send_telegram(f"‚ö†Ô∏è L·ªói l·∫•y s·ªë d∆∞: {str(e)}", chat_id,
                            bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        
        elif text == "üìà V·ªã th·∫ø":
            try:
                positions = get_positions(api_key=self.api_key, api_secret=self.api_secret)
                if not positions:
                    send_telegram("üì≠ Kh√¥ng c√≥ v·ªã th·∫ø n√†o ƒëang m·ªü", chat_id,
                                bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
                    return
                
                message = "üìà <b>V·ªä TH·∫æ ƒêANG M·ªû TR√äN BINANCE</b>\n\n"
                for pos in positions:
                    position_amt = float(pos.get('positionAmt', 0))
                    if position_amt != 0:
                        symbol = pos.get('symbol', 'UNKNOWN')
                        entry = float(pos.get('entryPrice', 0))
                        side = "LONG" if position_amt > 0 else "SHORT"
                        pnl = float(pos.get('unRealizedProfit', 0))
                        leverage = float(pos.get('leverage', 1))
                        
                        message += (
                            f"üîπ {symbol} | {side}\n"
                            f"üìä Kh·ªëi l∆∞·ª£ng: {abs(position_amt):.4f}\n"
                            f"üè∑Ô∏è Gi√° v√†o: {entry:.4f}\n"
                            f"üí∞ ƒêB: {leverage}x | PnL: {pnl:.2f} USDT\n\n"
                        )
                
                send_telegram(message, chat_id,
                            bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
            except Exception as e:
                send_telegram(f"‚ö†Ô∏è L·ªói l·∫•y v·ªã th·∫ø: {str(e)}", chat_id,
                            bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        
        elif text == "üéØ Chi·∫øn l∆∞·ª£c":
            strategy_info = (
                "üéØ <b>H·ªÜ TH·ªêNG BOT ƒê∆†N GI·∫¢N</b>\n\n"
                "ü§ñ <b>5 B∆Ø·ªöC HO·∫†T ƒê·ªòNG</b>\n"
                "1. üìä Ki·ªÉm tra v·ªã th·∫ø Binance\n"
                "2. üéØ X√°c ƒë·ªãnh h∆∞·ªõng ng∆∞·ª£c l·∫°i\n"  
                "3. üîç T√¨m coin ph√π h·ª£p\n"
                "4. üìà V√†o l·ªánh & qu·∫£n l√Ω TP/SL\n"
                "5. üîÑ Reset v√† l·∫∑p l·∫°i\n\n"
                
                "üìà <b>PH√ÇN T√çCH K·ª∏ THU·∫¨T</b>\n"
                "‚Ä¢ Volume tƒÉng + n·∫øn xanh ‚Üí MUA\n"
                "‚Ä¢ Volume tƒÉng + n·∫øn ƒë·ªè ‚Üí B√ÅN\n"
                "‚Ä¢ Volume gi·∫£m + n·∫øn th√¢n nh·ªè ‚Üí MUA\n"
                "‚Ä¢ ƒêa khung: 1m, 5m, 15m\n\n"
                
                "‚öñÔ∏è <b>QU·∫¢N L√ù R·ª¶I RO</b>\n"
                "‚Ä¢ T·ª± ƒë·ªông c√¢n b·∫±ng v·ªã th·∫ø\n"
                "‚Ä¢ M·ªói bot ƒë·ªôc l·∫≠p thread\n"
                "‚Ä¢ T·ª± reset sau m·ªói l·ªánh"
            )
            send_telegram(strategy_info, chat_id,
                        bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        
        elif text == "‚öôÔ∏è C·∫•u h√¨nh":
            balance = get_balance(self.api_key, self.api_secret)
            api_status = "‚úÖ ƒê√£ k·∫øt n·ªëi" if balance is not None else "‚ùå L·ªói k·∫øt n·ªëi"

            searching_bots = sum(1 for bot in self.bots if bot.status == "searching")
            trading_bots = sum(1 for bot in self.bots if bot.status == "open")

            config_info = (
                "‚öôÔ∏è <b>C·∫§U H√åNH H·ªÜ TH·ªêNG</b>\n\n"
                f"üîë Binance API: {api_status}\n"
                f"ü§ñ T·ªïng s·ªë bot: {len(self.bots)}\n"
                f"üîç ƒêang t√¨m coin: {searching_bots} bot\n"
                f"üìä ƒêang trade: {trading_bots} bot\n"
                f"üí∞ S·ªë d∆∞: {balance:.2f} USDT\n\n"
                f"üéØ <b>M·ªói bot ƒë·ªôc l·∫≠p - T·ª± reset ho√†n to√†n</b>"
            )
            send_telegram(config_info, chat_id,
                        bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        
        elif text.startswith("‚õî "):
            bot_id = text.replace("‚õî ", "").strip()
            if self.stop_bot(bot_id):
                send_telegram(f"‚õî ƒê√£ d·ª´ng bot {bot_id}", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
            else:
                send_telegram(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y bot {bot_id}", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
        
        elif text:
            self.send_main_menu(chat_id)
